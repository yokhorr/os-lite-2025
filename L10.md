Планирование процессов.
Реализация планировщиков.

Очередь. Обычная или цикличная.
Shortest job first -- максимальная эффективность, если знаем cpu burst. Обычно не знаем.
Либо отказ, либо угадывать.
Накапливание долга.
Многоуровневая очередь. Работает за константу.

1. Обязательная поддержка внешнего управления приритетов.

Всегда нужно оставлять backdoor, но чем больше возможностей внешнего воздействия оставляешь, тем хуже работает система.

2. Обеспечить эффективное использование ресурсов.

Нужно медленным, тяжёлым процессам давать больше непрерывного времени.

Удерживать процесс на своём ядре -- на своём разогретом кэше.
Однако несколько тяжёлых процессов могут сконцентрироваться на одном ядре, несколько лёгких -- на другом.

3. Обеспечить минимизацию накладных расходов.

Планировщик ест те же ресурсы, которые пытается сэкономить.

Чтобы предсказывать, нужно хранить в памяти большую статистическую информацию.
Много памяти нужно, так ещё и бегать по ней.

Хочется целочисленную арифметику.
Хочется хорошую асимптотику: хуже O(n) уже недопустимо.

4. Минимизация вероятности тупиков.

Один процесс захватил ресурс, но не может выполняться, пока есть процесс с большим приоритетом,
но тому тоже нужен тот же ресурс. Тупик.

Нужно создать алгоритм, который либо умеет узнавать о таких тупиках и чинить, либо предотвращать -- делать
невозможным их выполнение.

___

Никто не знает, как работает планировщик Windows.
Однакое кое-что знаем.

Используется концепция многоуровневых очередей.
Их используется 32.
Они разложены на 3 группы.
0, 1-15, 16-31.
Чем выше номер очереди, тем сильнее приоритет.
31 не ждёт никого, 0 ждёт всех.

В верхней касте находятся системные процессы, в нижней -- пользовательские.
В нулевой живёт системный процесс -- процесс, который обнуляет страницы в памяти.
И занимается он этим непрерывно.
Когда делать нечего -- почистим память.

Верхняя каста -- Realtime.
Нижняя каста -- User.

___

Классы приоритетов процессов:
1. Realtime      (24)
2. High          (13)
3. Above normal  (10)
4. Normal        (8)
5. Below normal  (6)
6. Idle          (4)

Можно установить приоритет процесса.

Realtime доступен только пользователю с правами администратора.
Однако крайне не рекомендуется использовать его.
Потому что могут возникать тупики.

___

Уровни насыщения потоков:
1. Time Critical (+15)
2. Highest       (+2)
3. Above Normal  (+1)
4. Normal        (0)
5. Below Normal  (-1)
6. Lowest        (-2)
7. Idle          (-15)

Менять их нельзя из интерфейса как пользователь.

Microsoft отказалась даже пытаться считать cpu burst.
Решили поощрять хорошие процессы.
Если процесс вернулся из ожидания -- он хороший. Дадим ему прибавку в очереди.
Квант в линуксе -- 12 тиков таймера.
Если процесс интерактивный, то повысим ему приоритет. Пусть ходит в диск.

Если некоторый процесс, который готов исполняться 4 секунды (очень много), то есть если в течение этого времени
он не получал процессорного времени, до назначим очередь 15 и дадим ему 2 кванта.
Вполне вероятно, что он захватил какой-то ресурс.

> Программа выполнила недопустимую операцию. Закрыть?
> Подождать.

___

Планировщик O(1). Линукс.

Многоуровневые очереди, разделённые на два потока. Но их 140.

40 очередей это User. От +19 до -20. Это nice.
Высшая каста -- это Realtime. Там могут быть только потоки ядра. Почему? Монолитное ядро.

Системные потоки пользуются кооперативной многозадачнстью.

В винде используется round robin, в линуксе -- fifo.

Существует вторая, ровно такая же структура.

Первая -- Active, и в ней все процессы.
Втоарая -- Non Active.

Active: если никого нет до процесса, то он выполнится.
Дальше он либо сам раньше уйдёт в ожидание -- и попадёт в хвост своей очереди, и напишем, сколько ему осталось.
Если же он добрал весь свой квант, то он уйдёт в Non Active очередь.

Рано или поздно все процессы перекочуют во вторую очередь.
Потом меняем указатели, Non Active становится Active, а Active становится Non Active.

Весь выбор сводится к тому, чтобы выбрать очередь. Их константа.
В памяти хранится битовый вектор из 140 бит. Если в очереди кто-то есть, то 1, иначе 0.
Есть инструкция, которая за один такт находит индекс первой единицы.

Добавлено исключение: если у процесса очень высокий приоритет и он при этом интерактивный,
то ему разрешается вернуться в ту же очередь и получить новый квант. Заместо ухода в Non Active.
Но если коэффициент интерактивности он ухудшит, то уже не дадут и он уйдёт ждать всех.

А вот как сломали одну из первых версий этого планировщика.
Рождаем процесс в очереди 0. Далее ведём себя хорошо -- повышаем себе приоритет.
Далее выполняем 199 из 200 мс, в последний момент рождает потомка и далее умираем.
Дети делают то же самое.
Нас все пропускают, мы только работаем, и с нами ничего не сделают.

Был придуман костыль. Когда рождается ребёнок, он делит оставшийся квант с родителем.

Выбор нужного процесса -- O(1), действительно.
Но вот подсчёт коэффициента и упорядочивание это уже не константа.

У всех процессов одинаково растёт знаменатель, и только у кого-то меняется числитель.
Тогда будем отдельно хранить числитель и знаменатель.
Будем хранить очередь процессов, упорядочивая их по времени исполнения.
Сделаем execution time и max execution time.
Выбираем процесс с минимальным execution time и даём ему работать max execution time -- накопленный долг.
То есть когда интерактивный процесс уйдёт, то когда он вернётся, то в начало, потому что до этого мало работал.
Очередь сделана на красно-чёрном дереве.

Вместо того, чтобы плодить очереди, Молнар придумал, что время процессов будет идти по-разному.
В зависимости от nice.

CFS -- completely fair scheduler.
RCFS -- really completely fair scheduler -- разрабатывается.

