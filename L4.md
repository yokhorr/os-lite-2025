Архитектура операционной системы.
А что такое архитектура?
Почему несколько слоёв?

Выделяют пять структур:
1. Функциональная
2. Информационная
3. Системная
4. Программная
5. Архитектура данных

Когда возникает архитектура?
1. Слишком сложная система. Нужна абстракция.
2. Команда постоянно меняется.

Нужно не только иметь документацию (её много).

___

**Функциональная архитектура**

Взгляд с позиции конечного пользователя.

___

**Информационная архитектура**

Информационные системы работают с информацией. Она представляется в виде объектов.
В винде -- все настройки хранятся в виде реестра. Это иерархическая база данных.
В линуксе -- все настройки это множество текстовых файлов. Всё есть файл. На самом деле они не файл, просто так
отображаются. В качестве информационного объекта выбрали текстовый файл.

___

**Системная архитектура**

Где какие фреймворки будут использовать, какие библиотеки, может готовое ПО.
Как будут компоненты связаны с интерфейсами между собой.
Как будет загружаться операцинная система?

___

**Программная архитектура**

Зависит от парадигмы, паттерна. Какие классы создадим, функции, как разделим ответственность.

___

**Архитектура данных**

Как упорядочивать, индексировать, использовать кэши.

___

Нужно обеспечить:
1. Производительность
2. Надёжность
3. Безопасность

Чего?
1. Аппаратного обеспечения
2. Пользовательского ПО
3. Данных
4. Интерфейсов (диалога с пользователем)

___

Функции ОС:
1. Управление разработкой и исполнением пользовательского ПО
    - API
    - Управление исполнением
    - Обнаружение ошибок
    - Высокоуровневый доступ к утройствам ввода-вывода (I/O)
    - Управление хранилищем
    - Мониторинг
2. Оптимизация ресурсов
    - Решение многокритериальной задачи
3. Поддержка администрирования и эксплуатации
    - Диагностика
    - Автоматическое восстановление
    - Средства ручного восстановления
4. Поддержка развития самой операционной системы
    - Механизмы обновлений
    - Дополнения (плагины, аддоны)

___

**API**

Как открылся файл вообще?
Функция fopen оборачивает системный вызов.
Передаёте номер и вектор параметров. А это неудобно.

В разы ускоряет разработку.

___

**Управление исполнением**

Нажал ярлык. Родился процесс. Ему надо дать ресурсы. Высвободить либо не дать. Замапить, где эти ресурсы.
Воткнуть во все планировщики. Ему нужна будет память. И ещё на куче будет выделять.

___

**Обнаружение ошибок**

RE: выход за границы массива, деление на ноль.
Reset. Хорошо, если есть логи.
Обработчик сигнала сделает дамп памяти около места его получения и сохранит.

___

**Высокоуровневый доступ к утройствам ввода-вывода (I/O)**

___

**Управление хранилищем**

Бэкапы.

___

**Мониторинг**

В том числе ресурсов.
Почему тормозит? Каких ресурсов не хватает? Что приводит к снижению производительности?
Как это измерить?
Чем более детальный мониторинг, тем более он нагружает те ресурсы, которые мониторит.

___

**Решение многокритериальной задачи**

Оптимизация -- подбор каких-то параметров.

Два основных подхода:

1) Суперкритерий (свёртка). Вводятся некоторые коэффициенты, нормируются. Взвешивается важность критерия.
Ну и далее поиск максимума целевой функции.

K = ak_1 + bk_2 = ck_3

Условный критерий.
K = ak_1 + bk_2, if k_3 > z

Компенсация открытости системы.

Цикл Дёминга или цикл PDCA.
Plan. Планируем вперёд какое-то количество шагов.
Do. Выполняем этот план, больше ничего не анализируем.
Check. Смотрим, достигли ли того, чего планировали.
Act. Исправляем ошибки, компенсируем возникшие проблемы, меняем приоритеты.

Далее снова планируем и так далее.

___

**Поддержка администрирования и эксплуатации**

Больше кода -- больше ошибок. Невозможно написать код без ошибок. Системы становятся слишком сложными.
Эмерджентность (синергия). Поотдельности -- ОК, вместе -- плохо.

___

