На этом этапе операционные системы не имеют привелегированного режима.
Можно запустить только одну программу (пакет).

Концепция мультипрограммной обработки.
Поведение программ в разные моменты времени разное.
Когда-то нужна память, когда-то нужен ввод-вывод.
Так ещё и таких устройств может быть много.
Возникают очереди.
Простаивают ресурсы. Возникают узкие места.

Так давайте в памяти распологать не одну программу, а несколько.
И давать программам ресурсы поочерди.
Задача о рюкзаке своего рода. Множественный рюкзак.
Если программ достаточно много одновременно работающих, при этом достаточно маленькое гранулирование, при этом
всем нужно что-то разное, то все ресурсы равномерно используются.

Задачу всё же решить не удаётся.

Диспетчер далее эволюционирует в мультипрограммную операционную систему.

Какие функции выполняет? Какие проблемы у нас есть?
1. Обеспечение разделения процессорного времени (processor sharing).
2. Memory sharing
3. Необходимость защиты памяти
4. Планирование ресурсов
5. Универсальный доступ к хранилищу
6. Межпроцессное взаимодействие

Многоядерностью можно пренебречь -- количество ядер на порядок меньше количества процессов.
Одно ядро -- один поток команд.

Псевдопараллельное выполнение -- по нескольку миллисекунд даёшь каждому процессу.

Первый подход -- *кооперативная многозадачность*.
Давайте через каждые 100 инструкций будем вставлять команду -- передай управление соседу.
Почему не работает?
1. Может найтись чел, который не будет вставлять такие команды -- борьба за ресурсы.
2. Йоу, ну у нас же циклы, ветви. Как ты 100 инструкций отмеришь?
В общем её попробовали и от неё отказались. Но через 40 лет к ней вернутся.
Кооперативную многозадачность используют Котлин, Го. В корутинах используется.
Ну это внутри одного проекта.

Второй подход -- *вытесняющая многозадачность*.
Ну, поставили часы. Таймер.
Он через равные промежутки времени генерирует прерывания. Заставляет процессор прервать выполнение потока команд.
Из выполняемых программ ни одна из них не знает, кто ещё есть и кому передать управление.
Так что часы передают управление диспетчеру, а он уже разберётся.
Срабатывает прерывание -- определяем, кто следующий -- передаём управление.
Но мы не можем мгновенно передать управление в другой процесс.
У нас же регистры процессора. Instruction Pointer, Stack Pointer, и т.д.
Контекст (пока) -- совокупность значений всех регистров.
Сохраняем текущий контекст, загружаем конеткст другого процесса.
И нам тогда даже не надо запоминать, куда вернуться, мы сохраним IP.

И вот мы решили проблему processor sharing.

___

А как насчёт разделения оперативной памяти? (memory sharing)
Если программ несколько, и в памяти они расположены в разных местах, мы не можем заранее знать,
какой у неё будет адрес, на что она ссылается в памяти.
Придумали понятие виртуальной памяти (виртуализации памяти).

Виртуальная память -- это абстракция, позволяющая при разработке или компиляции программ использовать
адресацию от виртуального нуля, а при запуске или исполнении подменять адреса на физические.
Я компилирую программу и говорю ей, что при запуске она начнётся с нулевого адреса.
Ну а далее просто на константу смещаемся.
Адреса можно преобразовать либо при загрузке в память, либо можно пересчитывать адрес только в момент обращения.
Где тогда такую мапу хранить и как по ней быстро бегать? Ну это потом разберёмся.

___

А что если вы выйдете за границы массива?
В пределах своей программы -- сам виноват. Сломал чужие данные -- очень плохо.

В зависимости от ошибки придёт сигнал.
У обработчика прерываний выше приоритет. Он есть у каждого процесса. Он наследуется от системного процесса.
В общем в вашем коде по меньшей мере есть стандартный обработчик.
Он перед смертью выполнит системный вызов, сделав дамп памяти вокруг той инструкции, где произошла ошибка где надо.
Чёрный ящик.
Ну и тогда более менее понятно где RE происходит.

С такой логикой перестаёт работать диспетчер.

Вводим понятие *привилегированного режима*.
В привилегированном режиме отключаем защиту памяти.
В непривилегированном попытка исполнить код диспетчера приведёт к access violation и убьёт этот процесс.
Есть специальная инструкцая, атомарно (реализовано аппартно) даёт привилегии.
И диспетчера отключена защита памяти. Даёт ему определённую ответственность.

Этот механизм получил название системный вызов -- *syscall*.
*Системный вызов* -- это обращение пользовательского процесса к ядру операционной системы с требованием предоставить
ресурс или выполнить привилегированную операцию.

___

Мы заранее не знаем, какие ресурсы понадобятся программе.

___

Проблема: универсальный доступ к хранилищу.

Хранилище забито. Моей программе нет места. Нужно дать другому компьютеру.
Как передать данные из хранилища в другие компьютеры?
Как переиспользовать код в разных проектах?
Чтобы не было жёсткой привязки к адресам хранилища. И хотим человекочитаемые адреса.

Сначала появляется файловая система, затем файлово-каталожная. Дерево или граф?
В винде всё ещё дерево, в линуксе может получиться направленный граф.
В винде не нужно контролировать циклы (их нет в дереве) зато.

___

Проблема: Межпроцессное взаимодействие.

Вот есть конвейеры: `|`.
stdout_1 >> stdin_2.
А как?
Три проблемы:
1) ...
2) ...
3) Чтение пустых данных. Как понять, что эта память уже была прочитана?

___

1963 г., компьютер B5000. Диспетчер умеет всё. Впервые употребляется термин, что он является операционной системой.
Называлась она Main Control Program (MCP). Вот это одна из первых операционных систем.

___

Третий этап: *сетевые операционные системы*.

Компьютер требует много энергии и обслуживающего персонала. Персональных компьютеров нет.
Компьютеры концентрируются в некоторых городах.
Всё больше компаний крупного и среднего бизнеса хотят использовать вычисления.
Люди покупали машинное время. Приходили люди с кодом, платили деньги. Считали реальное время, сколько код работает.

И теперь узкое место у нас input и output.
Писали код на бумаге, в уме отлаживали.
Если словил RE, то очень жаль.

___

AM -- амплитудная модуляция.
FM -- частотная модуляция.

Модулятор + демодулятор = модем.

Научились передавать цифры по телефону.

Проблема: не знаем, кто позвонил -- оплатил или нет?
Появляется понятие учётной записи. Авторизация, идентификация, аутентификация.
Появляется термин *login* -- logical income.
Аутентификация -- доказываете, что вы это вы. Чем-то.
Идентификация -- зафиксировали хэш.
Авторизация -- вам выдали права.

Появляются билинговые системы. Чтобы деньги считать.

Впервые появляется концепция балансировки нагрузки и взаимодействия серверов.
Как заставить людей звонить на сервера равномерно? Пока в одном месте ночь, в другом утро.
Надо попробовать отправить программу (данные в памяти) на другой сервер, а потом принять результат.

В результате третьего этапа мы получили автономность. Нет оператора. Можно удалённо ставить задания.
Можно балансировать нагрузку.

___

Четвёртый этап: мобильные или универсальные операционные системы.

___

