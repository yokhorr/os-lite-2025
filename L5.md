Какие информационные объекты должны существовать?
Это не структура данных, не пример реализации.
Это то, с помощью чего решаются задачи.

Эти объекты разделяются на подсистемы:
1. Управление процессами
2. Управление памятью
3. Управления файлами
4. Управление внешними устройствами (вводом-выводом)
5. Защита данных и администрирование
6. Интерфейсы

___

**Управление процессами**

1. Как этот процесс представить
2. Как управлять распределением ресурсов

1. Control Process Block -- или дескриптор процесса.
2. Очереди планирования

___

**CPB**:
Внутри -- три типа информации:
1. Идентификация (PID)
2. Ресурсы
3. История

`/proc` -- там много каталогов с числовыми кодами, это и есть PID'ы запущенных процессов, будут 1 и 2.
В этих каталогах много файлов с данными о процессе.

Для каждого процесса нужен маппинг ресурсов.
Память -- это множество страниц, они необязательно подряд лежат в физическом пространстве.
Всё есть файл. Но они не настоящие, `/proc` не существует на диске.

Конкуренция за ресурсы должна быть честной, но при этом эффективной.
Чем более разные потребности у потребителей, тем дальше справедливость от эффективности.
Так мы ещё и не знаем, что захочет процесс в будущем.
ОС надеется, что процесс будет вести себя стабильно. Для этого и собирает историческую информацию.
Ну, это усреднённые данные. На них и работает планировщик.

___

**Очереди планирования**

План -- расставить события во времени.

___

**Управление памятью**

Возникает две задачи:
1. Виртуальная память
2. Защита памяти

Любая структура данных будет эффективна либо на запись, либо на чтение.

Процесс не должен мешать другому процессу. Даже в случае ошибки обращаться только по своим адресам.
Есть выделять блоки памяти подряд -- защищать легко. Если раскидать -- нелегко.

___

**Управление файлами**

Оперативная память человеко-читаема. В переменых это всё человеко-читаемо.
А вот когда компилируешь, то уже всё, уже машинные адреса.
Нужна семантика в именовании.

И вот есть два подхода:
1. Преобразование символьных и физических адресов
2. Управление каталогом

Первое. Это хитрее, чем с оперативной памятью.
Оперативная память почти одинаковая для всех устройств.
А с хранилищами там по-разному, может трёхмерная даже быть, может двумерная, может даже одномерная.
Разные способы хранения уже приводят к трудностям.

Второе.
База данных -- набор фактов.

В винде нельзя один файл поместить в несколько папок. Можно делать ссылки, но они умрут, если файл умрёт.
А в линуксе можно. И это будет не синхронизация, это будет один объект, но в разных каталогах.

`ln file1 file2` -- ОК (один файл под разными именами)
`ln dir1 dir2` -- нельзя

___

**Управление внешними устройствами**

1. Драйвер
2. plug and play

Только ОС может взаимодействовать с железом.
Если любое ПО сможет пользоваться сетевыми интерфейсами, то всё смешается, безопасность нарушится, приоритеты сломаются.
Кто-то должен это всё координировать, этим и занимается ОС.

Новое устройство -- новая ОС?

Драйвер. В линуксе до сих пор называют "модуль ядра".
Так что любой производитель любого железа должен писать драйвера к любой ОС.

Откуда два скомпилированных кода знают, как друг с другом общаться?

Линукс вообще долго верил, что все всегда будут пересобирать ядро.

Любое устройство, когда подключается, пусть отдаёт свой код -- представляется.
Надо создать базу драйверов, сходить в эту базу, найти, кого обнаружили и взять драйвер.
И операционная система тоже пусть представляется.
Эта технология называется plug-and-play. (plug-and-pray)

___

**Защита данных и администрирование**

1. Учётные записи
2. Аудит (журнал)

___

**Подсистема пользовательского интерфейса**

1. CLI (command line interface)
2. GUI (grafical user interface)

