Взаимодействие процессов.

Оно бывает синхронное (передать данные, управление) -- есть ряд инструментов у ОС. Именованный канал например.
Обращение к именованному каналу -- системный вызов -- обрабатывается ядром.
Есть ещё сигналы.
Можно сделать так, чтобы процесс не завершился, получив сигнал access violation, но ОС всё равно не даст.

Неразделяемые ресурсы. В один момент может пользоваться только один процесс.
Один процесс печатает, потом второй захотел. Принтер либо не напечатает ничего и выдаст ошибку, либо напечатает ерунду.
Так что нужно запретить другим печатать в тот момент, пока печатает один процесс.
На самом деле не только с печатью такое. С файлом работа например. Или передача данных в какой-нибудь порт.

Четыре проблемы:
1. Взаимоисключение
2. Прогресс
3. Отсутствие голодания
4. Отсутствие тупика

Можно блокировать ресурс, чтобы другие процессы не лезли.
Если процесс будет на всём протяжении своей жизни блокировать ресурс, который он потенциально может использовать,
будет плохо.
Поэтому есть критические секции кода.
Условие взаимоисключения:
В один момент времени в критической секции относительно некоторого ресурса может находиться не более одного процесса.
Не должно быть ситуации, когда ресурс свободен. Существует процесс, который должен его использовать.
Но из-за особенностей управления ему не предоставляется доступ к ресурсу.

Отсутствие голодания: не должно быть ситуации, когда процесс неограниченно долго ждёт ресурс,
предоставляемый в это время другим процессам.

Сначала пытались решать задачу взаимоисключения, не нарушая условие прогресса.
Переход в однопрограммный режим.
Проблема: мы не знаем заранее, в какой момент какой процесс захочет попасть в критическую секцию.
Единственный выход: обернуть критическую секцию в пролог и эпилог.
Сначала объявляет, потом выполняет критическую секцию, потом отпускает ресурс.
Надо запретить прерывания, как только подходим к критической секции.
Проблема в том, что если с процессом что-то случится в критической секции,
его никто не спасёт: он ни на что не реагирует.
Пользовательским процессам запрещено переходить в этот режим.
Ядро операционной системы в некоторых случаях пользуется этим. Действенный метод.

1. Алгоритм замка.

```cpp
shared int lock = 0;

P_i() {
    while lock {};
    lock = 1;
    {
        critical section;
        lock = 0;
    }
}
```

Закрыли уже закрытую дверь в момент прерывания.

2. Алгоритм строгого чередования.

```cpp
shared int turn = 0;

P_i() {
    while (turn != i);
    {critical section}
    turn = 1 - i;
}
```

Нарушение условия прогресса. Ресурс свободен, есть процесс, которому нужно в критическую секцию,
он ждёт того, которому туда не нужно.

3. Флаги готовности

```cpp
shared int ready[2] = {0, 0};

P_i() {
    ready[i] = 1;
    // interrupt
    while (ready[1 - i]) {}
    {critical section}
    ready[i] = 0;
}
```

Если в том месте произойдёт прерывание, то есть оба процесса поднимут флаг, то будет тупик.

4. Алгоритм Петерсона (алгоритм вежливости)

```cpp
shared int ready[2] = {0, 0};
shared int turn = 0;
P_i() {
    ready[i] = 1;
    turn = 1 - i;
    while (ready[i - 1] && turn != i) {};
    {critical section}
    ready[i] = 0;
}
```

Работает всегда. Но если процессов много, то долго.

5. Аппаратная поддержка взаимоисключений (test and set)

```cpp
shared int lock = 0;
P_i() {
    while (Test_and_Set(&lock)) {}
    {critical section}
    lock = 0;
}
```

Постоянное дёргание ручки -- тратишь своё время, занимаешь ресурсы процессора, мешаешь другому исполняться.

6. Семафоры.

Семафор -- целая неотрицательная переменная, над которой разрешены две атомарные операции.

```cpp
P(S) {
    while (S == 0) {
        block(S);
    }
    S = S - 1;
}

V(S) {
    S = S + 1;
}
```

```cpp
Semaphore mutex = 1;
Semaphore empty = N; // количество не занятых ячеек
Semaphore full = 0;

Procucer() {
    while (true) {
        produce_item;
        P(empty);
        P(mutex);
        put_item;
        V(mutex);
        V(full);
    }
}

Consumer() {
    while (true) {
        P(full);
        P(mutex);
        set_item;
        V(mutex);
        V(empty);
        consume_item;
    }
}
```

___

