Диспетчеризация.
Управление процессами устроено через конечный автомат.

Первый автомат имел два состояния:
1. Исполнение
2. Ожидание

Исполнение -- использует процессорное время. Считается на процессоре.
В один момент времени это может быть один процесс.

Когда процесс рождается, он попадает в состояние ожидания, потому что кто-то другой выполняется.
Мы не можем выключить процессор, чтобы он ничего не делал. Он всегда что-то считает.

И вот появляется первая очередь. Процессы ожидают своего исполнения. Пока очередь это чёрный ящик.
Планировщик в каждый момент времени выбирает следующий процесс из очереди.
Процесс может либо уйти в исполнение, либо обратно в ожидание.
Почему в ожидание? Ну, прерывание сработало, отдали время кому-то другому.

Проблема этого подхода в том, что мы не знаем, чего конкретно ждёт процесс.
То ли ресурса конкретного, то ли вообще ничего ему не надо, он уже готов исполняться.
А что если он ждал операцию ввода-вывода? Вот мы ему дадим исполняться, а он не готов ещё.

___

Появляется теперь автомат с тремя состояниями:

1. Готовность [R]
2. Ожидание [D]
3. Исполнение [R]

0->1
1->3, 3->2, 3->1, 2->1.

___

При рождении попадает в готовность.
Из исполнения можно умереть, можно вернуться в готовность, можно уйти в ожидание.

Внутри ожидания тоже есть очереди, и их много.
Потому что там ожидание чего-то конкретного.

Непрерывемое ожидание может длиться очень долго, и может скопиться много зомби от потомков.

Готовность и Исполнение = R, running и runnable. Одинаковые вещи, мы не различаем,
потому что миллисекунды процесс исполняется, и пока статистика выведется, там уже десять раз всё поменяется.

___

1. Готовность [R]
2. Ожидание [D]
3. Исполнение [R]
4. Сон (прерываемое ожидание) [S] (suspended)
5. Остановлен [T] (terminated)
6. Zombie [Z]
7. Исключение (исключительная ситуация)
8. Готовность вне ОП
9. Ожидание вне ОП
10. Рождение

Сон прослушал.

Единственный способ попасть в terminated это получить сигнал `SIGSTOP`.
В линуксе ровно 64 сигнала: 32 POSIX и ещё 32 для линукса.
Сигнал 19 это `SIGSTOP`. Его можно провоцировать с клавиатуры, нажав `Ctrl + Z`.
Зачем?
Это искусственная кома считай. Организм пытаясь бороться делает только хуже. Ну и врачу нужно время разобраться.
Ну и вот. Если процесс ведёт себя странно. А swap в 10^5 раз медленнее. То вот надо убить.

Из исполнения любой процесс обязательно проходит через zombie состояние. 
Может ненадолго, но проходит.

Исключительная ситуация. Может другой поток не успел досчитать знаменатель, а другой уже на 0 поделил.
Теперь из исключения не обязательно уходить в зомби, можно в очередь вернуть его, дать шанс.

Нужен план.
Короткий горизонт планирования: брать всегда одно дело, наиболее предпочтительное.
В моменте смотришь и принимаешь решение. Так что оно точно актуально.
Однако тратится время на его принятие.

А можно один раз подумать, и затем следовать шагам.
Тогда не тратится лишнее время на планирование и сбор информации.
Но если ситуация меняется, то план может быть уже неоптимален.
Это вот долгосрочное планирование.

___

В ОС краткосрочное планирование -- в очереди из Готовности в Исполнение.
Потому что процессы себя ведут здесь непредсказуемо. Так что нечего анализировать.

Отдельный вид планирования -- в очередях ввода-вывода (это которые Ожидание).
Существуют разные диски, там разная физика, так что свои принципы планирования.

Вот есть низкоприоритетный процесс. Он доберётся до выполнения, но реально не скоро.
Давайте его выкинем в подкачку. А вот когда его очередь подойдёт -- вернём.
Это вот те случаи, когда вне ОП.
Это вот как раз среднесрочное планирование.

Долгосрочное планирование.
Ещё одно состояние -- рождение.
Родил процесс -- надолго поменял состояние ОС. Обратно никак.
Давайте тогда акт рождения сделаем управляемым.
Давайте рождение чуть придержим, а то систему вообще добъём.
Ну и вот здесь и появляется долгосрочное планирование.

___

1. Нужны критерии для планирование. Что такое хорошо и как сравнивать.
2. ?
3. Параметры планирования. Какой информацией можно пользоваться, чтобы принимать решения.

___

Есть три показателя эффективности:
1. Среднее время исполнения процесса
2. Среднее время ожидания (прогресс бар)
3. Время отклика.

Что хотим от алгоритма:
1. Предсказуемость
2. Небольшие накладные расходы
3. Масштабируемость.

___

Параметры планирования принято разделять на 4 группы:
системы/процесса * статические/динамические.

Статические системы -- это предельные значения ресурсов. Тактовая частота, объём оперативной памяти.
Динамические системы -- текущее состояние этих ресусрво (сколько свободно). Оно меняется.
Статические процесса -- может у него прав нет на интернет, тогда он от нас ничего такого не попросит.
Динамические процесса -- ...

