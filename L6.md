Системная архитектура.

Когда мы перешли к мультипрограммной ОС, возникла сложность, что нужно изолировать процессы друг от друга.
При этом потребовалось обеспечить коммуникацию между этими процессами.

Код, выполняющийся в привилегированном режиме имеет доступ ко всему.

В операционных системах приживаются простые решения:
1) должна работать очень быстро, потому что всегда задействована
2) должна быть надёжной

Так что два режима, вместо четырёх. Либо всё, либо ничего.

Код должен быть резидентен. Находиться в оперативной памяти, причём всегда в одинаковых адресах.

Если мы при загрузке каждый раз будем пересчитывать адреса, то гигабайт придётся пересчитывать, а это долго.
Виртуализация памяти каждую инструкцию можно сказать увеличивает в несколько раз.

Резидентность кода ОС обусловлена тем, что мы знаем, что он загрузится всегда первым,
причём в одни и те же адреса, то мы специально можем скомплировать код под конкретные адреса
и уже не нужно будет пересчитывать адреса.

Что ещё даёт резидентность.
Можно защитить код ОС, сказав, что вот отсюда до сюда нельзя.
Что если использовать своп?
Вот тут уже не обеспечить безопасность, потому что во-первых происходит пересылка данных, а во-вторых это
легко на диск, а там уже совсем что угодно можно стырить; можно конечно шифровать, но это оч долго.

Ну и вот. Код должен быть резидентен и в привилигерованном режиме.

Но вот следующая проблема.
Операционные системы становятся всё сложнее.
Резидентность начинает мешать...

Если ты вылетаешь за пределы массива в ОС, то никто тебя за руку не поймает, потому что это ты других ловишь, а не тебя.
Если много оперативы выделить под ОС, то пользовательскому ПО не хватит место, и оно будет уходить в своп.

Может, не всю ОС запихивать в привилигерованный режим и резидентность?
Может, какие-то компоненты не так важны?
Зачем, скажем, выделять память под печать? Мы же не печатем всё время. Да и печать не такая важная вещь.

Такие рассуждения привели к понятию ядра.
Ядро -- часть операционный системы, выполняемой в привилегированном режиме. Оно всегда резидентно.
Kernel mode. Режим ядра.
Но что тогда оставить в ядре, а что вынести за его пределы?

Танненбаум: минимум в ядро, максимум наружу.
Торвальдс: максимум в ядро, минимум наружу.
Золотую середину не нашли. Потому что критерии разные.

Так что сегодня параллельно существуют много различных архитектур ядра.
Не придумали идеальную архитектуру (и вряд ли придумают).
И вот есть много разных архитектур под конкретную задачу.
Так что нужно понимать плюсы и минусы каждой архитектуры.

Пять принципов ОС:
1. Принцип модульной организации
2. Функциональная избыточность
3. Функциональная избирательность
4. Параметрическая универсальность
5. Концепция многоуровневой иерархической операционной системы

___

## Принцип модульной организации

Абстракции.
Однако оси по ООП не строятся, ибо медленно.

___

## Функциональная избыточность

В 90-е пытались идти по пути узкоспециализированных ОС для каждого типа устройств.
Есть же специфичные задачи.

Однако огромные объёмы... годы разработки...
А оси плюс минус все похожи.
Это ж надо писать ПО и пересобирать под кучу осей.

Так что нет, давайте делать одну ОС, но заложить в неё функции подо всё.

Никогда вы не используюте в операционной системе всё, что в неё заложено.

___

## Функциональная избирательность

Мы закладываем в ОС, всё, что можем, но при этом могли бы убирать ненужное.

Как поотключать лишнее в винде.

___

## Параметрическая универсальность

Если у нас есть какие-то данные, они не должны быть в коде, они должны быть вынесены.
Всё, что может быть параметром, должно быть вынесено.

Кто будет сторожить сторожей?

В былые времена не предполагали, что размер файла может превосходить 2ГБ.
Ну и вот мы до сих пор на это натыкаемся.
В ext3 нельзя сохранить большой файл, если он слишком большой.
И вот ext4 когда стали делать, нужно с одной стороны обеспечить совместимость, но нужно решить проблему.

Вот что сделали:
Младшие биты -- для маленьких файлов.
Если нужны большие, то подключаются старшие биты.

___

## Концепция многоуровневой иерархической операционной системы

Какие бывают архитектуры:
1. Монолитная
2. Многослойная
3. Микроядерная архитектура
4. Модульное монолитное ядро

___

### Монолитная

Весь код ОС привилегирован и резидентен.
В монолитах не происходит абстрагирования и защиты отдельных процедур.
Кто угодно может вызвать кого угодно. Из любой процедуры вызывать любую процедуру.

Три слоя:
1. main program
2. services
3. utility

User -- Software -- [system call] -- main program -- services -- utilities -- [interrupts] -- hardware

Пусть ПО подстраивается под ОС, а не наоборот.
Что касается железа, оно зависит от физики, и поэтому здесь уже ОС под него подстраивается.

Main program определяет, кто из сервисов умеет делать то, что попросил софт.

У каждого процесса существует два стека.
Помимо пользовательского, есть стек ядра.
Когда любой процесс создался, создалось адресное пространство для пользователя.
Но в ядре тоже небольшой стек создаётся.
Так, например, `fopen` оборачивает системный вызов. Вот мы его используем.
Происходит переход в привилегированный режим.
Снимутся ограничения, и одновременно управление переходит к main program.
Тогда main program смотрит таблицу процессов, смотрит, кто активен, кто запросил syscall.
Идёт в адресное пространство, смотрим id процесса, смотрим его stack pointer,
из вершины его стека копируем себе эту вершину, в свой приватный стек.
И уже в своём стеке начинаем выполнять, что там надо.
А зачем мне нужен стек? Потому что сервис сходит в драйвер, вернётся обратно, вызовет другой сервис и так далее.
Вызовы, раскрутка.
Ядро отработало, у проги в стеке появилось всё, что нужно.

Слишком много наваливается на main program, она разрастается, а если становится сложной, то ненадёжной.

___

### Многослойная

ОС часть своих функций вынесла в аппаратуру (на железо).

1) Аппаратная поддержка ядра
2) Машинно-зависимые модули (HAL)
3) Базовые механизы ядра
4) Менеджер ресурсов
5) Системные вызовы и API
6) Software

Нужна совместимость, не на всякое железо можно всякую ось накатить.

Те кто думают, и те кто делают. Разделение задач.
Базовые механизмы ядра делают, а менеджеры ресурсов думают.

Пирамида Маслоу работает, потребности растут, больше комфорта, меньше думать.

> оказывается, надо знать физику, а на КТ её не изучают

___

Всё это резидентно и привилегированно, а оно очень большое. Так не годится.

### Микроядерная архитектура

User mode
Kernel mode

Kernel: системные вызовы, базовые механизмы, HAL, аппартная поддержка, Hardware
User: Software, HDD, App1, App2, ... Appk -- они все дёргают ядро.

Переход в режим ядра и обратно это не мгновенная история.

В монолите мы один раз переходили в ядро и обратно.
В микроядерной архитектуре мы много таких переходов делаем, закапываемся глубоко, так ещё и вернуться нужно.

> Деда мороза нет. Кто-то должен был вам это сказать

В микроядерке можно пересобирать маленькие кусочки, а не перекомплировать всё ядро.

И вот что на это ответил Торвальдс:

___

### Модульное монолитное ядро

Прослушал...

___

Ещё три вида ядра:

**Нано ядро**.
Там оставлена часть HAL уровня.
Оставлена часть самых нужных драйверов.
Оставлены самые базовые механизмы работы с ними.
Очень примитивные менеджеры.
Очень примитивные системные вызовы без API.

Эта вещь используется во всех гипервизорах.
Над ней будут другие ОС.
Создаём множество ОС, работающих одновременно. И вот внутри них уже всё будет работать нормальным образом.
А нам надо какой-то механизм переключения между ними сделать, вот нано-ядерная архитектура то и делает.

**Экзо-ядерная архитектура**
Менеджеры ресурсов загнали в kernel mode, а HAL и базовые механизмы вытащили в user mode.

Лампочка загорелась -- заменим чанк.

**Гибридная архитектура**

Прослушал.

