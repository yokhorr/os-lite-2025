Что такое процесс.

Нас интересует тот процесс, который появился в ОС когда программа запустилась.
Начинает требовать ресурсы, когда его запустили. Тогда начинает во времени развивать процесс.
По-разному просит у ОС ресурсы.

**Процесс** -- это совокупность набора исполняемых команд, ассоциированных с ним ресурсов
и контекста исполнения, находящаяся под управлением операционной системы.

Одну и ту же программу можно запустить, но у них будут разные ресурсы.
Управление процессом всё равно остаётся на стороне ОС.

___

Осветилить картинку. Можно использовать только одно ядро.
Потому что параллельные процессы упрутся в изоляцию адресного пространства.
Один процесс не может получить доступ к данным второго. Исключения делать нельзя.

Поэтому появилось понятие потока. (thread)
Давайте внутри процесса выделем некоторое количество тредов.
Набор команд для каждого будет свой, а ресурсы будут общие.
Тогда конкуренция между тредами либо контролируема, либо её нет (процессы не конкурируют).

**Поток** -- это совокупность набора исполняемых команд и контекста исполнения, разделяющая все или часть
ресурсов с другими потоками данного процесса, и находящаяся под управлением ОС.

___

В джаве многопоточность сделали удобной.
На плюсах это всё вручную делалось. Использовалась только там, где надо.
Java позволила без особого понимания и усилий делать многопоточный код.

___

Алгоритмы планирования очень дорогие. Хотя бы O(n) для планирования.
Так что много потоков иметь нехорошо.
Много потоков, они неэффективные, их надо перебирать.

ОС считается nice процессами те, что ничего не просят, а ещё лучше спят.
А что делает, если хочется отдать приоритет какому-то конкретному потоку?
Не стоит влезать руками править управление потоками.

___

Далее появляется третий уровень -- fiber.

**fiber** -- это совокупность набора исполняемых команд в контексте отдельного потока
под управлением пользовательского процесса.

Это держится на кооперативной многозадачности.

___

Процесс -- контейнер ресурсов.
Потоки -- ..
fiber -- гибкое управление кодом самого приложения

___

1. job / cgroup
2. process
3. thread
4. fiber

Пусть некоторая совокупность процессов объединится.

**job** -- совокупность процессов с общим ограничением на использование определённых ресурсов.

Контейнеризация -- некоторая совокупность процессов изолируется внутри ОС.

___

Функции подсистемы управления процессами:

- создание
- обеспечение ресурсами
- изоляция
- планирование
- диспетчеризация
- синхронизация
- межпроцессное взаимодействие
- завершение

___

Синхронизация. Процессы конкурируют во времени.
Разные процессы могут взять один и тот же ресурс одновременно. Race condition.

Межпроцессное взаимодействие.
Как передавать данные между адресными пространствами?
Как передать сигнал?

___

Создание и завершение процессов.

Процесс порождает процесс. Но кто порождает первый процесс?
В Linux процесс с пидом 0 это костыль. Его нету.
Ядро создаст процесс пидом 1 (отдельным способом), но его ппид будет 0.

В линуксе процессы создают дерево, а на самом деле даже два.
Есть дерево с корнем PID=1, а есть PID=2. У них родитель PID=0 (фиктивный).
PID=1 назывался init, теперь systemd. (d = daemon)
PID=2 назыавется kTread. (kernel tread)

___

Два способа создания процессов:
1. fork() + exec*()
2. clone()

___

fork() -- родитель клонирует самого себя. Создаётся полная копия адресного пространства родителя.
Затем системный вызов exec*() заменяет в новом адресном пространстве область, которая была связана с набором
команд, на новую.
В момент замены появляется PPID = родитель.

Почему exec*? Существуют много exec, но по-разному передаются параметры.
Хотели передавать параметры либо связным списком, либо вектором, так что оставили оба варианта.

Ребёнок не может получить больше, чем было у родителя.
Ctrl+C -- SIGINT. Когда процесс создавался, он отнаследовал таблицу обработчиков сигнала.
А у init'а были все. Вот так и наследуют.

А что если адресное пространства какого-то процесса будет слишком большим?
Так потомо ещё и заменять всё.
Но заранее не скажешь, поэтому надо отдавать всё.
Так что на самом деле страницы не копируются, а копируются только указатели на них.

Дочерний процесс может читать родителя. Доверяешь ребёнку.
А вот на запись не надо доверять.
Когда произойдёт обращение к этой странице либо ребёнка, либо родителя, вот тогда она раздвоится.
А до тех пор всё общее.

___

clone()

Это когда порождаешь процесс, у которого PPID равен твоему PPID. Сестринский процесс.

___

А что если один процесс умирает, что делать с его веткой дерева?
Были варианты:
1) дед подхватывает внука
2) всех сирот усыновляет init

А зачем нам вообще всё это дерево?
Ну, нужно как-то обрабатывать исключения. Узнать, что умерло и почему.
Когда процесс завершается, он отдаёт код своего завершения своему родителю.

___

sigChild() -- нужно сходить в таблицу процессов и прочитать код завершения ребёнка.

Таблица -- массив структур. В структуре в том числе код завершения. Строчка удаляется, когда родитель её прочитал.

zombie-процесс -- нет кода, нет ресурсов, но похоронить его нельзя, потому что от него осталась строчка,
которая не исчезнет, пока родитель её не прочитал, а с родителем что-то случилось.
Например, у него непрерывемое состояние, или может быть SIGSTOP.
Когда zombie станет много, кончится таблица (там лимит 65536).

> Быть зомби -- это нормально для процесса. Любой процесс проходит через это состояние.

___

А вот в винде нет дерева процессов, есть диспетчер процессов.
Диспетчер сам создаст, в чистом адресном пространстве, и родитель уже не обязан ничего делать с ребёнком,
pid конечно узнает, далее ответственности не несёт.
Соответственно zombie в винде быть не может, диспетчер жив всегда.
Процесс завершился -- диспетчер похоронит -- родитель получит уведомление.

